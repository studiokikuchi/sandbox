
<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Refraction | Tilt Water (WebGL)</title>
<style>
  :root{ --bg:#071225; --neon:#D7FF55; }
  html,body{
    margin:0; height:100%; overflow:hidden;
    background:var(--bg);
    touch-action:none;
    -webkit-user-select:none; user-select:none;
    -webkit-touch-callout:none;
    font-family:system-ui,-apple-system,sans-serif;
  }
  canvas{display:block; width:100%; height:100%;}
  .gate{
    position:fixed; inset:0;
    display:flex; flex-direction:column;
    align-items:center; justify-content:center;
    gap:14px;
    background:rgba(7,18,37,0.92);
    color:var(--neon);
    z-index:10;
    text-align:center;
    padding:24px;
  }
  .btn{
    background:transparent;
    border:1px solid var(--neon);
    color:var(--neon);
    padding:12px 18px;
    border-radius:999px;
    letter-spacing:0.08em;
    font-size:14px;
  }
  .sub{ opacity:.7; font-size:12px; line-height:1.6; max-width:34em; }
  .hud{
    position:fixed; left:12px; bottom:10px;
    color:rgba(215,255,85,0.35);
    font-size:12px; z-index:5; pointer-events:none;
    white-space:pre;
  }
</style>
</head>
<body>

<div class="gate" id="gate">
  <div>Refraction</div>
  <button class="btn" id="start">ENTER</button>
  <div class="sub">
    カメラ＋傾きで水面屈折（WebGL）。<br>
    iPhoneは「カメラ」と「モーション/方向」の許可が必要です。
  </div>
</div>

<video id="v" playsinline muted autoplay style="display:none;"></video>
<canvas id="c"></canvas>
<div class="hud" id="hud"></div>

<script id="fragShader" type="x-shader/x-fragment">
precision highp float;
uniform sampler2D u_tex;
uniform vec2 u_res;
uniform float u_time;
uniform float u_beta;
uniform float u_gamma;
varying vec2 v_uv;

// 2D hash
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453);
}

// 2D noise
float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    vec2 u = f*f*(3.0-2.0*f);
    return mix(a, b, u.x) + (c - a)*u.y*(1.0-u.x) + (d - b)*u.x*u.y;
}

// fbm (fractal brownian motion)
float fbm(vec2 p) {
    float f = 0.0;
    float amp = 0.5;
    for(int i=0;i<5;i++){
        f += amp * noise(p);
        p *= 2.0;
        amp *= 0.5;
    }
    return f;
}

void main() {
    vec2 uv = v_uv;
    float t = u_time;

    // 傾きから流れ方向・強度を決定
    float nx = clamp(u_gamma / 45.0, -1.0, 1.0);
    float ny = clamp(u_beta  / 45.0, -1.0, 1.0);
    float flow = sqrt(nx*nx + ny*ny);
    float angle = atan(ny, nx);
    float strength = mix(0.015, 0.045, flow); // 歪み量

    // ノイズベクトル
    vec2 dir = vec2(cos(angle), sin(angle));
    vec2 base = uv * 2.0;
    float n = fbm(base*1.2 + dir*t*0.25 + t*0.08);
    float n2 = fbm(base*2.7 - dir*t*0.18 - t*0.13);
    float n3 = fbm(base*5.0 + t*0.07);
    float d = n*0.7 + n2*0.25 + n3*0.08;

    // 歪みオフセット
    vec2 offset = dir * d * strength * 1.5;
    offset += vec2(
      fbm(base*2.0 + t*0.12) * 0.012,
      fbm(base*2.0 - t*0.11) * 0.012
    );

    // 色収差（RGBずらし）
    float chroma = 0.004 + 0.012*strength;
    vec2 uvR = uv + offset + chroma*vec2(0.5,0.0);
    vec2 uvG = uv + offset;
    vec2 uvB = uv + offset - chroma*vec2(0.5,0.0);

    vec3 col;
    col.r = texture2D(u_tex, uvR).r;
    col.g = texture2D(u_tex, uvG).g;
    col.b = texture2D(u_tex, uvB).b;

    // vignette
    float vign = smoothstep(0.95,0.55, length(uv-0.5));
    col *= vign;

    // 暗い背景色を混ぜる
    col = mix(vec3(0.027,0.071,0.145), col, 0.98);

    gl_FragColor = vec4(col,1.0);
}
</script>

<script id="vertShader" type="x-shader/x-vertex">
attribute vec2 a_pos;
varying vec2 v_uv;
void main(){
  v_uv = a_pos*0.5+0.5;
  gl_Position = vec4(a_pos,0,1);
}
</script>

<script>
(() => {
  const video = document.getElementById('v');
  const canvas = document.getElementById('c');
  const gate = document.getElementById('gate');
  const hud  = document.getElementById('hud');
  let w=0,h=0,dpr=1;

  // --- WebGL初期化 ---
  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  if(!gl){ alert('WebGL unsupported'); return; }

  // --- シェーダ用意 ---
  function compileShader(src, type){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
      throw new Error(gl.getShaderInfoLog(sh));
    }
    return sh;
  }
  function createProgram(vsSrc, fsSrc){
    const vs = compileShader(vsSrc, gl.VERTEX_SHADER);
    const fs = compileShader(fsSrc, gl.FRAGMENT_SHADER);
    const prg = gl.createProgram();
    gl.attachShader(prg, vs);
    gl.attachShader(prg, fs);
    gl.linkProgram(prg);
    if(!gl.getProgramParameter(prg, gl.LINK_STATUS)){
      throw new Error(gl.getProgramInfoLog(prg));
    }
    return prg;
  }

  // --- シェーダソース取得 ---
  const vsSrc = document.getElementById('vertShader').textContent;
  const fsSrc = document.getElementById('fragShader').textContent;
  const program = createProgram(vsSrc, fsSrc);
  gl.useProgram(program);

  // --- フルスクリーン矩形 ---
  const posLoc = gl.getAttribLocation(program, 'a_pos');
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1, 1,-1, -1,1, 1,1
  ]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

  // --- ユニフォーム ---
  const uni = name => gl.getUniformLocation(program, name);
  const u_tex   = uni('u_tex');
  const u_res   = uni('u_res');
  const u_time  = uni('u_time');
  const u_beta  = uni('u_beta');
  const u_gamma = uni('u_gamma');

  // --- テクスチャ ---
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  // --- リサイズ ---
  function resize(){
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    w = canvas.width  = Math.floor(innerWidth  * dpr);
    h = canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width  = innerWidth  + "px";
    canvas.style.height = innerHeight + "px";
    gl.viewport(0,0,w,h);
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // --- センサー ---
  let beta=0, gamma=0;
  function onOri(e){
    beta  = (e.beta  ?? 0);
    gamma = (e.gamma ?? 0);
  }

  // --- カメラ ---
  async function startCamera(){
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" },
      audio: false
    });
    video.srcObject = stream;
    await video.play();
  }

  async function requestMotion(){
    // iOS permission gate
    if (typeof DeviceOrientationEvent !== "undefined" &&
        typeof DeviceOrientationEvent.requestPermission === "function") {
      const res = await DeviceOrientationEvent.requestPermission();
      if(res !== "granted") throw new Error("motion permission denied");
    }
    addEventListener("deviceorientation", onOri, {passive:true});
  }

  // --- メインループ ---
  function render(t){
    // カメラ映像をテクスチャにアップロード
    if(video.readyState >= 2){
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, video);
    }
    gl.useProgram(program);
    gl.uniform2f(u_res, w, h);
    gl.uniform1f(u_time, t*0.001);
    gl.uniform1f(u_beta, beta);
    gl.uniform1f(u_gamma, gamma);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.uniform1i(u_tex, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(render);
  }

  async function start(){
    try{
      await startCamera();
      await requestMotion();
      gate.style.display = "none";
      requestAnimationFrame(render);
    }catch(err){
      hud.textContent = "permission/camera error";
      console.error(err);
    }
  }

  document.getElementById('start').addEventListener('click', start);
})();
</script>
</body>
</html>